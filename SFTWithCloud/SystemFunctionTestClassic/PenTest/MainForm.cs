//*********************************************************
//
// Copyright (c) Microsoft. All rights reserved.
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
using System;
using System.Drawing;
using System.Resources;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Windows.Forms;

namespace PenTest
{
    public partial class MainForm : Form
    {

        #region Fields

        private static ResourceManager LocRM;
        private const int WM_POINTERUPDATE = 0x0245;

        #endregion // Fields

        #region Constructor

        /// <summary>
        /// Initializes a new instance of the MainForm form class.
        /// </summary>
        public MainForm()
        {
            LocRM = new ResourceManager("win81FactoryTest.AppResources.Res", typeof(win81FactoryTest.TestForm).Assembly);

            InitializeComponent();
            this.WindowState = FormWindowState.Maximized;
            FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;

            SetString();
        }

        #endregion // Constructor

        /// <summary>
        /// Gets Windows message. Catch for Pen messages. 
        /// </summary>
        /// <param name="m">The Windows Message to process.</param>
        [PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
        protected override void WndProc(ref Message m)
        {
            switch (m.Msg)
            {
                case WM_POINTERUPDATE:
                    DecodePointer(ref m);
                    break;
                case 0x201:
                    DecodeMouseClick(ref m); //left button up, ie. a click
                    break;
                default:
                    break;
            }

            // Call parent WndProc for default message processing.
            base.WndProc(ref m);

        }

        /// <summary>
        /// Decode Pen messages. Clear control based on position of Pen action.  
        /// </summary>
        /// <param name="m">The Windows Message to decode.</param>
        private void DecodePointer(ref Message m)
        {
            int pointerId = LoWord(m.WParam.ToInt32());
            NativeMethods.POINTER_INFO pointer = new NativeMethods.POINTER_INFO();

            if (!NativeMethods.GetPointerInfo(pointerId, ref pointer))
            {
                // Get pointer info failed.
                return;
            }
            if (pointer.pointerType == NativeMethods.POINTER_INPUT_TYPE.PEN)
            {
                if (pointer.PointerFlags.HasFlag(NativeMethods.POINTER_FLAGS.INCONTACT))
                {
                    Point screenPoint = new Point(pointer.PtPixelLocation.X, pointer.PtPixelLocation.Y);
                    Point panelPoint = PenPanel.PointToClient(screenPoint);
                    Control c = PenPanel.GetChildAtPoint(panelPoint);

                    if (c == null) { 
                        return; 
                    }

                    if (pointer.PointerFlags.HasFlag(NativeMethods.POINTER_FLAGS.FIRSTBUTTON) &&
                        (c.BackColor == Color.YellowGreen || c.BackColor == Color.Crimson))
                    {
                        //pen down
                        c.Dispose();
                    }
                    else if (pointer.PointerFlags.HasFlag(NativeMethods.POINTER_FLAGS.SECONDBUTTON) &&
                        c.BackColor == Color.Gold)
                    {
                        //pen erase (POINTER_FLAGS.SECONDBUTTON)
                        c.Dispose();
                        
                    }
                    //check if grids are cleared
                    CheckFinish();
                }
            }
        }

        /// <summary>
        /// Decode Mouse Click messages. If Exit clicked, exit application with result = Fail
        /// </summary>
        /// <param name="m">The Windows Message to decode.</param>
        private void DecodeMouseClick(ref Message m)
        {
            Point point = new Point(m.LParam.ToInt32());
            Control c = PenPanel.GetChildAtPoint(point);
            if (c != null && c == ExitLbl)
            {
                Program.ExitApplication(255);
            }
        }

        /// <summary>
        /// Check if grid on form is cleared.
        /// </summary>
        private void CheckFinish()
        {
            if (PenPanel.Controls.Count <= 3)
            {
                Program.ExitApplication(0);
            }
        }

        /// <summary>
        /// Retrieves the low-order word from the specified value.
        /// </summary>
        private static int LoWord(int number)
        {
            return (number & 0xffff);
        }

        /// <summary>
        /// Initializes strings from SystemFunctionTestClass resources
        /// </summary>
        private void SetString()
        {
            InstructionLabel.Text = LocRM.GetString("PenInstruction1");
            InstructionLabel2.Text = LocRM.GetString("PenInstruction2");
            ExitLbl.Text = LocRM.GetString("Exit");
        }
    }

    /// <summary>
    /// Using [DllImport("user32")] API
    /// </summary>
    internal static class NativeMethods
    {


        /// <summary>
        /// Gets the information for the specified pointer associated with the current message.
        /// </summary>
        [DllImport("user32")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool GetPointerInfo(int pointerID, ref POINTER_INFO pointerInfo);

        #region pointer enum

        internal enum POINTER_INPUT_TYPE
        {
            POINTER = 0x00000001,
            TOUCH = 0x00000002,
            PEN = 0x00000003,
            MOUSE = 0x00000004
        }
        [Flags]
        internal enum POINTER_FLAGS
        {
            NONE = 0x00000000,
            NEW = 0x00000001,
            INRANGE = 0x00000002,
            INCONTACT = 0x00000004,
            FIRSTBUTTON = 0x00000010,
            SECONDBUTTON = 0x00000020,
            THIRDBUTTON = 0x00000040,
            FOURTHBUTTON = 0x00000080,
            FIFTHBUTTON = 0x00000100,
            PRIMARY = 0x00002000,
            CONFIDENCE = 0x00004000,
            CANCELED = 0x00008000,
            DOWN = 0x00010000,
            UPDATE = 0x00020000,
            UP = 0x00040000,
            WHEEL = 0x00080000,
            HWHEEL = 0x00100000,
            CAPTURECHANGED = 0x00200000,
        }
        [Flags]
        internal enum VIRTUAL_KEY_STATES
        {
            NONE = 0x0000,
            LBUTTON = 0x0001,
            RBUTTON = 0x0002,
            SHIFT = 0x0004,
            CTRL = 0x0008,
            MBUTTON = 0x0010,
            XBUTTON1 = 0x0020,
            XBUTTON2 = 0x0040
        }
        #endregion

        #region pointer structs

        [StructLayout(LayoutKind.Sequential)]
        internal struct POINT
        {
            public int X;
            public int Y;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct POINTER_INFO
        {
            public POINTER_INPUT_TYPE pointerType;
            public int PointerID;
            public int FrameID;
            public POINTER_FLAGS PointerFlags;
            public IntPtr SourceDevice;
            public IntPtr WindowTarget;
            [MarshalAs(UnmanagedType.Struct)]
            public POINT PtPixelLocation;
            [MarshalAs(UnmanagedType.Struct)]
            public POINT PtPixelLocationRaw;
            [MarshalAs(UnmanagedType.Struct)]
            public POINT PtHimetricLocation;
            [MarshalAs(UnmanagedType.Struct)]
            public POINT PtHimetricLocationRaw;
            public uint Time;
            public uint HistoryCount;
            public uint InputData;
            public VIRTUAL_KEY_STATES KeyStates;
            public long PerformanceCount;
            public int ButtonChangeType;
        }

        #endregion 
    }
}
